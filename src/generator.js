const fs = require('fs').promises;
const path = require('path');
const chalk = require('chalk');
const handlebars = require('handlebars');

/**
 * Project Generator
 * 
 * Handles the actual project creation logic including validation,
 * directory creation, and file generation.
 */
class ProjectGenerator {
  constructor(projectName) {
    this.projectName = projectName;
    this.projectPath = path.resolve(process.cwd(), projectName);
    this.templatesPath = path.resolve(__dirname, '..', 'templates');
    
    // Template variables for handlebars rendering
    this.templateVars = {
      PROJECT_NAME: projectName,
      PROJECT_DESCRIPTION: `A FastAPI project generated by SuperFastAPI CLI`,
      AUTHOR_NAME: 'Your Name <your.email@example.com>',
      PYTHON_VERSION: '^3.11',
      FASTAPI_VERSION: '^0.104.1',
      UVICORN_VERSION: '^0.24.0'
    };
  }

  /**
   * Generate the FastAPI project
   */
  async generate() {
    // Validate project name
    this.validateProjectName();
    
    // Check if directory already exists
    await this.checkDirectoryExists();
    
    // Create project directory
    await this.createProjectDirectory();
    
    // Generate all files from templates
    await this.generateFromTemplates();
    
    console.log(chalk.green(`‚úÖ FastAPI project '${this.projectName}' created successfully!`));
    console.log(chalk.blue(`üìÅ Project directory: ${this.projectPath}`));
    console.log(chalk.yellow('\nüöÄ Next steps:'));
    console.log(chalk.white(`  cd ${this.projectName}`));
    console.log(chalk.white('  poetry install'));
    console.log(chalk.white('  poetry run uvicorn app.main:app --reload'));
  }

  /**
   * Validate the project name
   */
  validateProjectName() {
    if (!this.projectName) {
      throw new Error('Project name is required');
    }

    // Check for valid project name (alphanumeric, hyphens, underscores)
    const validNameRegex = /^[a-zA-Z0-9_-]+$/;
    if (!validNameRegex.test(this.projectName)) {
      throw new Error('Project name can only contain letters, numbers, hyphens, and underscores');
    }

    // Check length
    if (this.projectName.length < 1 || this.projectName.length > 50) {
      throw new Error('Project name must be between 1 and 50 characters');
    }
  }

  /**
   * Check if the project directory already exists
   */
  async checkDirectoryExists() {
    try {
      await fs.access(this.projectPath);
      throw new Error(`Directory '${this.projectName}' already exists`);
    } catch (error) {
      // If the directory doesn't exist, that's what we want
      if (error.code !== 'ENOENT') {
        throw error;
      }
    }
  }

  /**
   * Create the project directory
   */
  async createProjectDirectory() {
    try {
      await fs.mkdir(this.projectPath, { recursive: true });
    } catch (error) {
      throw new Error(`Failed to create project directory: ${error.message}`);
    }
  }

  /**
   * Generate all project files from templates
   */
  async generateFromTemplates() {
    try {
      // Define the project structure to create
      const projectStructure = [
        // Root level files
        { template: 'pyproject.toml.hbs', output: 'pyproject.toml' },
        { template: 'README.md.hbs', output: 'README.md' },
        { template: '.gitignore.hbs', output: '.gitignore' },
        
        // App directory and files
        { template: 'app/__init__.py.hbs', output: 'app/__init__.py' },
        { template: 'app/main.py.hbs', output: 'app/main.py' },
        
        // Tests directory and files
        { template: 'tests/__init__.py.hbs', output: 'tests/__init__.py' }
      ];

      // Generate each file from its template
      for (const item of projectStructure) {
        await this.generateFileFromTemplate(item.template, item.output);
      }
      
    } catch (error) {
      throw new Error(`Failed to generate project files: ${error.message}`);
    }
  }

  /**
   * Generate a single file from a template
   */
  async generateFileFromTemplate(templatePath, outputPath) {
    try {
      // Read the template file
      const templateFullPath = path.join(this.templatesPath, templatePath);
      const templateContent = await fs.readFile(templateFullPath, 'utf8');
      
      // Compile and render the template with variables
      const template = handlebars.compile(templateContent);
      const renderedContent = template(this.templateVars);
      
      // Ensure the output directory exists
      const outputFullPath = path.join(this.projectPath, outputPath);
      const outputDir = path.dirname(outputFullPath);
      await fs.mkdir(outputDir, { recursive: true });
      
      // Write the rendered content to the output file
      await fs.writeFile(outputFullPath, renderedContent, 'utf8');
      
      console.log(chalk.gray(`  ‚úì Created ${outputPath}`));
      
    } catch (error) {
      throw new Error(`Failed to generate ${outputPath} from ${templatePath}: ${error.message}`);
    }
  }

  /**
   * Read and render a template file
   */
  async renderTemplate(templatePath, variables = {}) {
    try {
      const templateFullPath = path.join(this.templatesPath, templatePath);
      const templateContent = await fs.readFile(templateFullPath, 'utf8');
      
      // Merge provided variables with default template variables
      const mergedVars = { ...this.templateVars, ...variables };
      
      const template = handlebars.compile(templateContent);
      return template(mergedVars);
    } catch (error) {
      throw new Error(`Failed to render template ${templatePath}: ${error.message}`);
    }
  }

  /**
   * Create a directory if it doesn't exist
   */
  async ensureDirectory(dirPath) {
    try {
      await fs.mkdir(dirPath, { recursive: true });
    } catch (error) {
      throw new Error(`Failed to create directory ${dirPath}: ${error.message}`);
    }
  }

  /**
   * Write content to a file, creating directories as needed
   */
  async writeFile(filePath, content) {
    try {
      const dir = path.dirname(filePath);
      await this.ensureDirectory(dir);
      await fs.writeFile(filePath, content, 'utf8');
    } catch (error) {
      throw new Error(`Failed to write file ${filePath}: ${error.message}`);
    }
  }
}

module.exports = { ProjectGenerator };