{{#if SUPABASE_AUTH}}
"""
Authentication routes for Supabase integration.
Provides login, register, logout, password reset, and email verification endpoints.
"""

from typing import Dict, Any
from fastapi import APIRouter, Depends, HTTPException, status, Request
from fastapi.responses import JSONResponse
from pydantic import BaseModel, EmailStr
import logging

from app.services.auth import get_auth_service, AuthService, AuthenticationError
from app.api.middleware.auth import get_current_user, verify_token
from app.models.user import UserCreate, UserResponse

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/auth", tags=["authentication"])


# Request/Response models
class LoginRequest(BaseModel):
    """Login request model."""
    email: EmailStr
    password: str


class LoginResponse(BaseModel):
    """Login response model."""
    message: str
    user: Dict[str, Any]
    access_token: str
    refresh_token: str
    token_type: str = "bearer"


class RegisterResponse(BaseModel):
    """Registration response model."""
    message: str
    user: Dict[str, Any]


class TokenRefreshRequest(BaseModel):
    """Token refresh request model."""
    refresh_token: str


class TokenRefreshResponse(BaseModel):
    """Token refresh response model."""
    access_token: str
    refresh_token: str
    token_type: str = "bearer"


class PasswordResetRequest(BaseModel):
    """Password reset request model."""
    email: EmailStr


class PasswordUpdateRequest(BaseModel):
    """Password update request model."""
    new_password: str


class EmailVerificationRequest(BaseModel):
    """Email verification request model."""
    token: str
    email: EmailStr


class MessageResponse(BaseModel):
    """Generic message response model."""
    message: str


@router.post("/register", response_model=RegisterResponse, status_code=status.HTTP_201_CREATED)
async def register(
    user_data: UserCreate,
    auth_service: AuthService = Depends(get_auth_service)
) -> RegisterResponse:
    """
    Register a new user account.
    
    Args:
        user_data: User registration data
        auth_service: Authentication service dependency
        
    Returns:
        Registration response with user data
        
    Raises:
        HTTPException: If registration fails
    """
    try:
        result = await auth_service.register_user(user_data)
        
        return RegisterResponse(
            message=result["message"],
            user=result["user"].__dict__ if hasattr(result["user"], '__dict__') else result["user"]
        )
        
    except AuthenticationError as e:
        logger.warning(f"Registration failed: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=e.message
        )
    except Exception as e:
        logger.error(f"Unexpected registration error: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Registration failed due to internal error"
        )


@router.post("/login", response_model=LoginResponse)
async def login(
    login_data: LoginRequest,
    auth_service: AuthService = Depends(get_auth_service)
) -> LoginResponse:
    """
    Authenticate user with email and password.
    
    Args:
        login_data: Login credentials
        auth_service: Authentication service dependency
        
    Returns:
        Login response with tokens and user data
        
    Raises:
        HTTPException: If login fails
    """
    try:
        result = await auth_service.login_user(login_data.email, login_data.password)
        
        return LoginResponse(
            message="Login successful",
            user=result["user"].__dict__ if hasattr(result["user"], '__dict__') else result["user"],
            access_token=result["access_token"],
            refresh_token=result["refresh_token"]
        )
        
    except AuthenticationError as e:
        logger.warning(f"Login failed: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=e.message
        )
    except Exception as e:
        logger.error(f"Unexpected login error: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Login failed due to internal error"
        )


@router.post("/logout", response_model=MessageResponse)
async def logout(
    request: Request,
    current_user: UserResponse = Depends(get_current_user),
    auth_service: AuthService = Depends(get_auth_service)
) -> MessageResponse:
    """
    Logout current user and invalidate session.
    
    Args:
        request: FastAPI request object
        current_user: Current authenticated user
        auth_service: Authentication service dependency
        
    Returns:
        Logout confirmation message
        
    Raises:
        HTTPException: If logout fails
    """
    try:
        # Extract token from Authorization header
        authorization = request.headers.get("Authorization", "")
        if authorization.startswith("Bearer "):
            access_token = authorization.split(" ")[1]
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid authorization header"
            )
        
        result = await auth_service.logout_user(access_token)
        
        return MessageResponse(message=result["message"])
        
    except AuthenticationError as e:
        logger.warning(f"Logout failed: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=e.message
        )
    except Exception as e:
        logger.error(f"Unexpected logout error: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Logout failed due to internal error"
        )


@router.post("/refresh", response_model=TokenRefreshResponse)
async def refresh_token(
    refresh_data: TokenRefreshRequest,
    auth_service: AuthService = Depends(get_auth_service)
) -> TokenRefreshResponse:
    """
    Refresh access token using refresh token.
    
    Args:
        refresh_data: Refresh token data
        auth_service: Authentication service dependency
        
    Returns:
        New access and refresh tokens
        
    Raises:
        HTTPException: If token refresh fails
    """
    try:
        result = await auth_service.refresh_token(refresh_data.refresh_token)
        
        return TokenRefreshResponse(
            access_token=result["access_token"],
            refresh_token=result["refresh_token"]
        )
        
    except AuthenticationError as e:
        logger.warning(f"Token refresh failed: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=e.message
        )
    except Exception as e:
        logger.error(f"Unexpected token refresh error: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Token refresh failed due to internal error"
        )


@router.post("/reset-password", response_model=MessageResponse)
async def reset_password(
    reset_data: PasswordResetRequest,
    auth_service: AuthService = Depends(get_auth_service)
) -> MessageResponse:
    """
    Send password reset email to user.
    
    Args:
        reset_data: Password reset request data
        auth_service: Authentication service dependency
        
    Returns:
        Password reset confirmation message
        
    Raises:
        HTTPException: If password reset fails
    """
    try:
        result = await auth_service.reset_password(reset_data.email)
        
        return MessageResponse(message=result["message"])
        
    except AuthenticationError as e:
        logger.warning(f"Password reset failed: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=e.message
        )
    except Exception as e:
        logger.error(f"Unexpected password reset error: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Password reset failed due to internal error"
        )


@router.post("/update-password", response_model=MessageResponse)
async def update_password(
    password_data: PasswordUpdateRequest,
    request: Request,
    current_user: UserResponse = Depends(get_current_user),
    auth_service: AuthService = Depends(get_auth_service)
) -> MessageResponse:
    """
    Update user password.
    
    Args:
        password_data: New password data
        request: FastAPI request object
        current_user: Current authenticated user
        auth_service: Authentication service dependency
        
    Returns:
        Password update confirmation message
        
    Raises:
        HTTPException: If password update fails
    """
    try:
        # Extract token from Authorization header
        authorization = request.headers.get("Authorization", "")
        if authorization.startswith("Bearer "):
            access_token = authorization.split(" ")[1]
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid authorization header"
            )
        
        result = await auth_service.update_password(access_token, password_data.new_password)
        
        return MessageResponse(message=result["message"])
        
    except AuthenticationError as e:
        logger.warning(f"Password update failed: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=e.message
        )
    except Exception as e:
        logger.error(f"Unexpected password update error: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Password update failed due to internal error"
        )


@router.post("/verify-email", response_model=MessageResponse)
async def verify_email(
    verification_data: EmailVerificationRequest,
    auth_service: AuthService = Depends(get_auth_service)
) -> MessageResponse:
    """
    Verify user email with verification token.
    
    Args:
        verification_data: Email verification data
        auth_service: Authentication service dependency
        
    Returns:
        Email verification confirmation message
        
    Raises:
        HTTPException: If email verification fails
    """
    try:
        result = await auth_service.verify_email(
            verification_data.token,
            verification_data.email
        )
        
        return MessageResponse(message=result["message"])
        
    except AuthenticationError as e:
        logger.warning(f"Email verification failed: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=e.message
        )
    except Exception as e:
        logger.error(f"Unexpected email verification error: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Email verification failed due to internal error"
        )


@router.get("/me", response_model=UserResponse)
async def get_current_user_info(
    current_user: UserResponse = Depends(get_current_user)
) -> UserResponse:
    """
    Get current authenticated user information.
    
    Args:
        current_user: Current authenticated user
        
    Returns:
        Current user data
    """
    return current_user


@router.get("/health")
async def auth_health_check() -> Dict[str, str]:
    """
    Health check endpoint for authentication service.
    
    Returns:
        Health status
    """
    return {"status": "healthy", "service": "authentication"}
{{/if}}